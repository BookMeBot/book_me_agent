import anthropic
import os
from dotenv import load_dotenv

load_dotenv()

ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")

client = anthropic.Client(api_key=ANTHROPIC_API_KEY)


def answer_question(context, question):
    """
    Answer a user's question based on dynamic context using Anthropic's client.
    :param context: Context string (hotel, listing, or neighborhood details).
    :param question: User query.
    :return: Answer generated by the agent.
    """
    # Construct the prompt for the language model
    prompt = f"""
    You are an assistant that answers questions based on the provided context.
    Context: {context}
    Question: {question}
    Provide a concise, helpful answer.
    """
    print("in answer tool")
    try:
        # Send the request to the language model
        response = client.completions.create(
            model="claude-3-5-sonnet-20241022",
            prompt=prompt,
            max_tokens=250,
            temperature=0.7,
        )

        # Extract the answer from the response
        answer = response.choices[0].text.strip()
        return answer

    except Exception as e:
        print(f"An error occurred while generating an answer: {e}")
        return "I'm sorry, I couldn't generate an answer at this time."


def check_and_return_payload(data):
    required_fields = [
        "location",
        "startDate",
        "endDate",
        "numberOfGuests",
        "numberOfRooms",
        "budgetPerPerson",
        "currency",
    ]

    # Check if all required fields are present and not None
    missing_fields = [field for field in required_fields if not data.get(field)]

    if not missing_fields:
        # All fields are present, calculate totalBudget
        data["totalBudget"] = data["numberOfGuests"] * data["budgetPerPerson"]
        return {
            "data": {
                "chatId": "-4555870136",
                "completedData": True,
                "response": {"requestData": data},
            }
        }
    else:
        # Some fields are missing
        return {
            "data": {
                "chatId": "-4555870136",
                "completedData": False,
                "response": f"We need more data: {', '.join(missing_fields)}",
            }
        }


def search_web(query):
    """
    Perform a web search based on the provided query.
    :param query: The search query extracted from the tool input.
    :return: Search results or a message indicating the search was performed.
    """
    # Implement the search logic here
    print(f"Performing web search for query: {query}")
    # TODO: Update this
    return "Search results for the query."


def find_tool_call(response_content):
    """
    Search through the response content to find the first tool call.
    :param response_content: List of content blocks from the response.
    :return: Tuple of tool name and input if a tool call is found, otherwise (None, None).
    """
    for block in response_content:
        if isinstance(block, dict) and block.get("type") == "tool_use":
            tool_name = block.get("name", "unknown")
            tool_input = block.get("input", {})
            return tool_name, tool_input
    return None, None


def process_response(response, messages):
    print("Response received from API.")
    print(f"Response: {response}")

    if response.stop_reason == "tool_use":
        # Use the helper function to find the tool call
        tool_name, tool_input = find_tool_call(response.content)
        print("tool_name", tool_name)

        if tool_name == "question":
            # Extract the question and ask the user
            question = tool_input.get("question", "")
            print(f"Bot: {question}")
            user_input = input("You: ")
            messages.append({"role": "user", "content": user_input})
            return True  # Continue the loop to process the next message

        elif tool_name == "answer":
            # Use the user's question as context
            context = messages[-1][
                "content"
            ]  # Assuming the last user message is the context
            question = tool_input.get("query", "")
            answer = answer_question(context, question)
            print(f"Bot: {answer}")
            messages.append({"role": "assistant", "content": answer})
            return True

        elif tool_name == "search":
            # Extract query and call search_web
            query = tool_input.get("booking_data", "")
            search_results = search_web(query)
            print(f"Search Results: {search_results}")
            messages.append({"role": "assistant", "content": search_results})
            return True
    # If no function was called, prompt the user to call a function
    messages.append(
        {
            "role": "user",
            "content": "Please call one of these functions: search, booking, question, answer.",
        }
    )
    return False  # break loop


def run_agent(messages, booking_data):

    while True:
        payload = check_and_return_payload(booking_data)
        if payload["data"]["completedData"]:
            return payload["data"]["response"]
        try:
            print("Sending request to API...")
            response = client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=1024,
                tools=[
                    {
                        "name": "search",
                        "description": "Search for hotels based on booking data and user feedback.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "booking_data": {
                                    "type": "string",
                                    "description": "Booking data, never null.",
                                },
                                "user_feedback": {
                                    "type": "string",
                                    "description": "User feedback data, can be null.",
                                },
                            },
                            "required": ["booking_data"],
                        },
                    },
                    {
                        "name": "booking",
                        "description": "Book a hotel based on user preferences.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "hotel_id": {
                                    "type": "string",
                                    "description": "ID of the hotel to book.",
                                }
                            },
                            "required": ["hotel_id"],
                        },
                    },
                    {
                        "name": "question",
                        "description": "Ask the user for more information if key info is missing.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "question": {
                                    "type": "string",
                                    "description": "Question to ask the user.",
                                }
                            },
                            "required": ["question"],
                        },
                    },
                    {
                        "name": "answer",
                        "description": "Answer random questions like 'What is the area like?'",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "query": {
                                    "type": "string",
                                    "description": "The question to answer.",
                                }
                            },
                            "required": ["query"],
                        },
                    },
                ],
                messages=messages,
            )

            if not process_response(response, messages):
                break

        except Exception as e:
            print(f"An error occurred: {e}")
            break

    return messages


def main():
    messages = []
    print("Welcome to the CLI chat with BookMeBot!")
    while True:
        user_input = input("You: ")
        if user_input.lower() in ["exit", "quit"]:
            print("Exiting the chat. Goodbye!")
            break
        messages.append({"role": "user", "content": user_input})
        # Example booking data
        booking_data = {
            "location": "New York City",
            "startDate": 1692806400,
            "endDate": 1692892800,
            "numberOfGuests": 2,
            "numberOfRooms": 1,
            "features": ["Wi-Fi", "swimming pool"],
            "budgetPerPerson": 150,
            "currency": "USD",
        }
        responses = run_agent(messages, booking_data)
        for response in responses:
            if response["role"] == "assistant":
                print(f"Bot: {response['content']}")


if __name__ == "__main__":
    main()
