from typing import Any, Dict, Optional
import anthropic
import os
from dotenv import load_dotenv
import json
import requests
from datetime import datetime
from urllib.parse import quote

load_dotenv()

ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")

client = anthropic.Client(api_key=ANTHROPIC_API_KEY)


def answer_question(context, question):
    """
    Answer a user's question based on dynamic context using Anthropic's client.
    :param context: Context string (hotel, listing, or neighborhood details).
    :param question: User query.
    :return: Answer generated by the agent.
    """
    # Construct the prompt for the language model
    prompt = f"""
    You are an assistant that answers questions based on the provided context.
    Context: {context}
    Question: {question}
    Provide a concise, helpful answer.
    """
    print("in answer tool")
    try:
        # Send the request to the language model
        response = client.completions.create(
            model="claude-3-5-sonnet-20241022",
            prompt=prompt,
            max_tokens=250,
            temperature=0.7,
        )

        # Extract the answer from the response
        answer = response.choices[0].text.strip()
        return answer

    except Exception as e:
        print(f"An error occurred while generating an answer: {e}")
        return "I'm sorry, I couldn't generate an answer at this time."


def check_and_return_payload(data):
    required_fields = [
        "location",
        "startDate",
        "endDate",
        "numberOfGuests",
        "numberOfRooms",
        "budgetPerPerson",
        "currency",
    ]

    # Check if all required fields are present and not None
    missing_fields = [field for field in required_fields if not data.get(field)]

    if not missing_fields:
        # All fields are present, calculate totalBudget

        return {
            "data": {
                "chatId": "-4555870136",
                "completedData": False, #come back and change this
                "response": {"requestData": data},
            }
        }
    else:
        # Some fields are missing
        return {
            "data": {
                "chatId": "-4555870136",
                "completedData": False,
                "response": f"We need more data: {', '.join(missing_fields)}",
            }
        }


def search_web(query):
    """
    Search for hotels on Travala.com
    :param query: The search query containing booking details
    :return: JSON array of hotel results
    """
    print(f"Searching Travala for query: {query}")
    
    # Parse the query if it's a string
    if isinstance(query, str):
        try:
            query = json.loads(query)
        except json.JSONDecodeError:
            print("Error parsing query string to JSON")
            return {"hotels": []}

    # Format dates to YYYY-MM-DD
    try:
        checkin = datetime.fromisoformat(query.get('checkin', '').replace('Z', '')).strftime('%Y-%m-%d')
        checkout = datetime.fromisoformat(query.get('checkout', '').replace('Z', '')).strftime('%Y-%m-%d')
    except ValueError as e:
        print(f"Error parsing dates: {e}")
        return {"hotels": []}

    # Construct the Travala API URL
    base_url = "https://api.travala.com/api/v2/hotels/search"
    
    # Build the parameters
    params = {
        "city": query.get('location', ''),
        "checkIn": checkin,
        "checkOut": checkout,
        "rooms": query.get('rooms', 1),
        "adults": query.get('guests', 1),
        "children": 0,  # Add if needed
        "currency": "USD",
        "page": 1,
        "limit": 10  # Number of results to return
    }
    
    headers = {
        "accept": "application/json",
        # Add any required API keys or authentication headers
        "User-Agent": "Your-Bot-Name/1.0"
    }

    try:
        response = requests.get(base_url, params=params, headers=headers)
        if response.status_code == 200:
            data = response.json()
            
            # Transform Travala response to our format
            hotels = []
            for hotel in data.get('hotels', []):
                hotels.append({
                    "id": hotel.get('id'),
                    "name": hotel.get('name'),
                    "location": hotel.get('address', {}).get('city'),
                    "price": {
                        "amount": hotel.get('price', {}).get('amount'),
                        "currency": "USD",
                        "per": "night"
                    },
                    "amenities": hotel.get('amenities', []),
                    "rating": hotel.get('rating', {}).get('score'),
                    "available": True,
                    "url": f"https://travala.com/hotel/{hotel.get('slug')}",
                    "thumbnail": hotel.get('thumbnail'),
                    "description": hotel.get('description')
                })
            
            return {"hotels": hotels}
        else:
            print(f"Error from Travala API: {response.status_code}")
            return {"hotels": []}

    except Exception as e:
        print(f"Error searching Travala: {e}")
        return {"hotels": []}


def find_tool_call(content):
    tool_block = next((block for block in content if block.type == 'tool_use'), None)
    
    print("tool_block", tool_block)
    if tool_block:
        print(f"Found tool: {tool_block.name}")  # Will print "Found tool: search"
        return tool_block.name, tool_block.input
        
    return None, None


def process_response(response, messages):
    print("Response received from API.")
    
    if response.stop_reason == "tool_use":
        # Use the helper function to find the tool call
        tool_name, tool_input = find_tool_call(response.content)
        print("tool_name", tool_name)

        if tool_name == "question":
            # Extract the question and ask the user
            question = tool_input.get("question", "")
            print(f"Bot: {question}")
            user_input = input("You: ")
            messages.append({"role": "user", "content": user_input})
            return True  # Continue the loop to process the next message

        elif tool_name == "answer":
            # Use the user's question as context
            context = messages[-1][
                "content"
            ]  # Assuming the last user message is the context
            question = tool_input.get("query", "")
            answer = answer_question(context, question)
            print(f"Bot: {answer}")
            messages.append({"role": "assistant", "content": answer})
            return True

        elif tool_name == "search":
            # Extract query and call search_web
            query = tool_input.get("booking_data", "")
            search_results = search_web(query)
            print(f"Search Results: {search_results}")
            messages.append({"role": "assistant", "content": search_results})
            return True
    # If no function was called, prompt the user to call a function
    messages.append(
        {
            "role": "user",
            "content": "Please call one of these functions: search, booking, question, answer.",
        }
    )
    return False  # break loop


def run_agent(messages: list, booking_data: Optional[Dict[str, Any]] = None):
    while True:
        if booking_data is None:
            booking_data = {}  # Initialize as an empty dictionary if None

        payload = check_and_return_payload(booking_data)
        if payload["data"]["completedData"]:
            # Return a list of dictionaries with the expected structure
            return [{"role": "assistant", "content": payload["data"]["response"]}]

        # If not all data is complete, ask for more information
        print(payload["data"]["response"])
        for field in payload["data"]["response"].split(": ")[1].split(", "):
            booking_data[field] = input(f"Please provide {field}: ")
        try:
            formatted_messages = []
            
            # Check if we have valid booking data
            if booking_data:
                # Add booking data context to the first message
                formatted_msg = {
                    "role": "user",
                    "content": f"""Search for the best hotels with these criteria:
                    Location: {booking_data['location']}
                    Dates: {booking_data['startDate']} to {booking_data['endDate']}
                    Guests: {booking_data['numberOfGuests']}
                    Rooms: {booking_data['numberOfRooms']}
                    Features: {', '.join(booking_data['features'])}
                    Budget: {booking_data['budgetPerPerson']} {booking_data['currency']} per person"""
                }
                formatted_messages.append(formatted_msg)
            
            # Only include user messages, skip assistant messages
            for msg in messages:
                if msg["role"] == "user":
                    formatted_messages.append(msg)
            
            print("Formatted messages:", formatted_messages)  # Debug log
            
            print("Sending request to API...")
            response = client.messages.create(
                model="claude-3-sonnet-20240229",
                system="You are a helpful assistant that helps users book hotels. You MUST use the search tool when booking criteria is provided.",
                messages=formatted_messages,
                max_tokens=1024,
                tools=[
                    {
                        "name": "search",
                        "description": "Search for hotels based on booking data and user feedback.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "booking_data": {
                                    "type": "string",
                                    "description": "Booking data, never null.",
                                },
                                "user_feedback": {
                                    "type": "string",
                                    "description": "User feedback data, can be null.",
                                },
                            },
                            "required": ["booking_data"],
                        },
                    },
                    {
                        "name": "booking",
                        "description": "Book a hotel based on user preferences.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "hotel_id": {
                                    "type": "string",
                                    "description": "ID of the hotel to book.",
                                }
                            },
                            "required": ["hotel_id"],
                        },
                    },
                    {
                        "name": "question",
                        "description": "Ask the user for more information if key info is missing.",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "question": {
                                    "type": "string",
                                    "description": "Question to ask the user.",
                                }
                            },
                            "required": ["question"],
                        },
                    },
                    {
                        "name": "answer",
                        "description": "Answer random questions like 'What is the area like?'",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "query": {
                                    "type": "string",
                                    "description": "The question to answer.",
                                }
                            },
                            "required": ["query"],
                        },
                    },
                ]
            )
            
            # # Check if there's a tool call in the response content
            # tool_calls = [
            #     block for block in response.content 
            #     if isinstance(block, dict) and block.get("type") == "tool_calls"
            # ]
            
            # if tool_calls:
            #     tool_call = tool_calls[0]["tool_calls"][0]
            #     tool_name = tool_call["function"]["name"]
            #     tool_input = json.loads(tool_call["function"]["arguments"])
            #     print(f"Tool called: {tool_name} with input: {tool_input}")
            #     # Process the tool call...
            # else:
            #     print("No tool call found in response")
            #     messages.append({
            #         "role": "user",
            #         "content": "Please use one of the available tools (search, booking, question, or answer) to respond."
            #     })

            if not process_response(response, messages):
                break

        except Exception as e:
            print(f"An error occurred: {e}")
            break

    return messages


def main():
    messages = []
    print("Welcome to the CLI chat with BookMeBot!")
    while True:
        user_input = input("You: ")
        if user_input.lower() in ["exit", "quit"]:
            print("Exiting the chat. Goodbye!")
            break
        messages.append({"role": "user", "content": user_input})
        # Example booking data
        booking_data = {
            "location": "New York City",
            "startDate": 1692806400,
            "endDate": 1692892800,
            "numberOfGuests": 2,
            "numberOfRooms": 1,
            "features": ["Wi-Fi", "swimming pool"],
            "budgetPerPerson": 150,
            "currency": "USD",
        }
        responses = run_agent(messages, booking_data)

        # Debugging: Print the type and content of responses
        print("Type of responses:", type(responses))
        print("Content of responses:", responses)

        for response in responses:
            if isinstance(response, dict) and response.get("role") == "assistant":
                print(f"Bot: {response['content']}")
            else:
                print("Unexpected response format:", response)


if __name__ == "__main__":
    main()
